import pandas as pd
import sys
import pathlib as pl
import tkinter as tk
from tkinter import filedialog
from tkinter.ttk import Treeview
from tkinter import ttk

background_color_main='#262624'
text_color="#E9E9E9"
button_backg_color="#30302E"
module_level={}

class CycloMeter():
    def __init__(self, path):
        self.pathAssign(path)
        self.msToKM('average speed')
        self.msToKM('max speed')
        self.secsToHour('moving time')
        self.condition=None
        self.sort_column = None
        self.sort_ascending = True

    def pathAssign(self, path: str):
        path = pl.Path(path)
        try:
            df = pd.read_csv(path)
        except Exception as e:
            raise IOError(f"Failed to read CSV: {e}") from e
        df.columns = [c.lower() for c in df.columns]
        self.data = df.copy()   # keep copy
        return self
    
    def sortValues(self, column):
        
        if self.sort_column==column:
            self.sort_ascending=not self.sort_ascending
        else:
            self.sort_ascending=True
        
        self.sort_column=column
        self.data = self.data.sort_values(by=column, ascending=self.sort_ascending)
    
    def setCondition(self, condition):
        if condition is None:
            self.condition=None
        else:
            self.condition=condition
    
    def filterResults(self, column: str, operator: str, value: float):
        if column=='':
            condition=None
            self.setCondition(condition)
            print('Filter is removed, insert table for default view.')
            pass
        elif operator == ">":
            value=int(value)
            condition=self.data[column]>value
            self.setCondition(condition)
            print('Filterization is complete!')
            return True
        elif operator == "<":
            value=int(value)
            condition=self.data[column]<value
            self.setCondition(condition)
            print('Filterization is complete!')
            return True
        else:
            print('Invalid operation.')
            return False
    
    def extractColumn(self, column:str):
        '''return column
        mutates self.data obj'''
        column=column.lower()
        if column in self.data.columns:
            return self.data[f"{column}"]
        else:
            raise KeyError("Column not found.")

    def extractMultiColumns(self, column:list):
        """Takes list with items as column str"""

        return self.data[column]

    def msToKM(self, column:str):
        col = column.lower()
        if col not in self.data.columns:
            raise KeyError(col)
        self.data = self.data.assign(**{f"{col} kmh": (self.data[col].astype(float) * 3.6).round(2)})

    def secsToHour(self, column):
        '''convert speed format to kmh'''
        if column in self.data.columns:
            meter=self.extractColumn(column)
            meter=meter/3600
            meter=round(meter, 3)
            self.data[f"{column}/h"]=meter

class TextRedirector():
    '''displays cmd line on GUI'''
    def __init__(self, text_widget:tk.Text, delay=50):
        self.text_widget = text_widget
        self.delay = delay
        self.text = ""
        self.index = 0

    def write(self,text):
        if self.index == 0:
            self.text_widget.configure(state='normal')
            self.text_widget.delete("1.0", "end")
            self.text_widget.configure(state='disabled')
            self.text = text
            self.insert_next_char()

    def insert_next_char(self):
        if self.index < len(self.text):
            char = self.text[self.index]
            self.text_widget.configure(state='normal')
            self.text_widget.insert("end", char)
            self.text_widget.see("end")
            self.text_widget.configure(state='disabled')

            self.index += 1
            self.text_widget.after(self.delay, self.insert_next_char)
        else:
            self.index = 0

    def flush(self):
        pass

class EntryField():
    def __init__(self, parent:tk.Tk, text:str):
        self.frame=tk.Frame(parent)
        self.entry=tk.Entry(self.frame)
        self.text=text
        self.label=tk.Label(self.frame, text=self.text)
    
    def packButtonHelper(self):
        self.entry.pack(side=tk.RIGHT)
        self.label.pack(side=tk.LEFT)
        self.frame.pack(side="top")

def loadFile():
    items=['activity id', 'activity date', 'moving time/h', 'distance', 'max heart rate', 'average heart rate', 'average speed kmh', 'max speed kmh', 'average watts', 'calories'] 
    path=filedialog.askopenfilename()

    if path:
        cyclingObj=CycloMeter(path)
        cyclingObj.data=cyclingObj.data[items]
        module_level['obj']=cyclingObj
    else:
        pass
    return cyclingObj

def packItems(item):
    #NEEDS UPDATE
    return item.pack()

def displayData(cyclingObj:CycloMeter):
    
    if cyclingObj.condition is not None: #If data is filtered, adjust the view.
        display_data:pd.Dataframe=cyclingObj.data[cyclingObj.condition]
    else: #Unfiltered, raw data copy.
        display_data:pd.Dataframe=cyclingObj.data #iterate dataframe records and get Series
    return display_data

def updateStatusBar(status_bar:tk.Text):
    sys.stdout=TextRedirector(status_bar)

def treeview_init(tree_view:Treeview, display_data, pandasRows, cyclingObj:CycloMeter):
    '''Adjust, insert and clear treeview'''

    for t in tree_view.get_children(): tree_view.delete(t)

    #A bit complex but briefly, when clicked calls on sortedValues then 
    # insertTable again, sortedValues directly mutates the self.data then 
    # insertedtable just normally calls on that object with mutated data etc
    for i in list(display_data.columns): 
        tree_view.heading(i, text=i, command=lambda col=i: (cyclingObj.sortValues(col), insertTable(tree_view, cyclingObj))) 
        tree_view.column(i, width=180) #column sorting
    
    for index, value in pandasRows: #Iterating through pandasRows
        raw_values=value.values #Series obj (bool T/F) to raw values
        tree_view.insert('','end',values=raw_values.tolist()) #''(start) to end insertion of columns not records
    print(f"Table insertion is complete!") #debugging needs removed on scaffolding

def insertTable(tree_view, cyclingObj:CycloMeter):

    display_data=displayData(cyclingObj)
    tree_view['columns']=list(display_data.columns) #update tree_view obj
    tree_view.column('#0', width=0, stretch=False)
    pandasRows=display_data.iterrows() #iterate dataframe records and get Series
    treeview_init(tree_view, display_data, pandasRows, cyclingObj)

def retrieveEntry(colmn,op,setVal, cyclingObj:CycloMeter):
    '''Return input of textBox'''
    colmn=colmn.get()
    operator=op.get()
    val=setVal.get()
    cyclingObj.filterResults(colmn,operator,val)
    
def packTextButtonHelper(window):
    status_bar_frame=tk.Frame(window)
    status_bar=tk.Text(status_bar_frame, state='disabled', height=1, width=40)
    return status_bar, status_bar_frame

def initButtons(window, count, label_names:list):
    '''count: number of fields expected
       label_names: list with strings that matches lenght of count'''
    if count == len(label_names):
        items=[]
        for j in label_names:
            entry_field=EntryField(window,j)
            items.append(entry_field)
        return items
    else:
        raise ValueError('Count is less or more than labels')

def initStatusBar(window):
    status_bar_tuple=packTextButtonHelper(window)
    updateStatusBar(status_bar_tuple[0])
    return status_bar_tuple

def applyStyle(window:tk.Tk):
    style=ttk.Style(master=window)
    window.option_add('*Text.font', ('Segoe UI', 12))
    style.theme_use('clam')

    layers=['*Button', '*Text', '*Label', '*Entry']
    for i in layers: 
            window.option_add(f'{i}.foreground', text_color)
            window.option_add(f'{i}.background', button_backg_color)

#Dict styling applications. Clean, sweet, warm... :D
    background='#262624'
    foreground='#E9E9E9'
    fieldbackground='#262624'
    dictionary={
        'Treeview':
        {
            'foreground':foreground,
            'background':background,
            'fieldbackground':fieldbackground,
            'font':('Segoe UI', 12)
        },
        'Treeview.Heading':
        {
            'foreground':foreground,
            'background':background,
            'fieldbackground':fieldbackground
        }
    }
    
    for widget_names, properties in dictionary.items():
            style.configure(widget_names,**properties) #KWARGS is where magic happens, makes key value pairs form variable. e.g. background='#262624'

    background=('pressed', '!disabled', "#6791C1"), ('active', '#262624')
    foreground=('pressed', '#E9E9E9'), ('active', '#E9E9E9')
    dictionary={
        'Treeview': 
        {
            'foreground':foreground,
            'background':(('selected','#6793C1'),)+background
        },
        'Treeview.Heading':
        {
            'foreground':foreground,
            'background':background,
        }
    }

    for widget_name, properties in dictionary.items():
        style.map(widget_name,**properties)
    
def programInitialize():
    
    window=tk.Tk(className="cycloMeter")
    window.configure(background=background_color_main)
    window.geometry('1200x800')
    applyStyle(window)

    tree_view=Treeview(window, height=26)
    buttonLoadFile=tk.Button(window, text='Load CSV File', command=loadFile)
    
    buttonInsertTable=tk.Button(window, text="Insert Table", command=lambda: insertTable(tree_view, module_level['obj']))
    boxes=initButtons(window,3,["column:","operator:","value:"])
    column_field, operator_field, value_field=boxes
    status_bar, status_bar_frame=initStatusBar(window)
    buttonFilter=tk.Button(window, text='Filter', command=lambda:retrieveEntry(column_field.entry,operator_field.entry,value_field.entry, module_level['obj'])) #text box
    
    for i in [tree_view,buttonLoadFile,buttonFilter,buttonInsertTable]: i.pack()
    for i in boxes:i.packButtonHelper()
    for i in status_bar_frame,status_bar: i.pack()

    window.mainloop()

if __name__ == "__main__":
    programInitialize()
    
    """
    STATUS: 
        Loading columns, data works
        Filtering works
        Interface is a bit better
        
    TODO:
        -Do .exe
        -Filterization is single dimensional, increase it for multiple columns and filterizations
        -Expand filterization errors

    """